
# Autochthon is a 32 bit, load and store architecture
#
#



instructions:

  # [Memory Access Instructions]
  #
  # Memory can be read/written in either 1 or 4 byte chunks
  - loadbyte: [reg, reg]
  - loadword: [reg, reg]
  - storebyte: [reg, reg]
  - storeword: [reg, reg]

  # The symbol table contains a list of (index, address) pairs
  - loadsym: [word, reg]

  # Put a literal value into a register
  - fill: [word, reg]

  - push: [reg]
  - pop: [reg]
  - call: [reg]
  - jump: [word] # ip relative unconditional jump
  - je: [word]
  - jne: [word]

  # [Arithmetic Instructions]
  - add: [reg, reg, reg]
  - sub: [reg, reg, reg]
  - mul: [reg, reg, reg]
  - div: [reg, reg, reg]

  # [IO Instructions]
  - ioreadbyte: [reg]
  - iowritebyte: [reg]

  - nop: []

  # Dump the contents of memory and registers to stdout of the interpreter
  - debug: []


registers: [
  # The instruction pointer holds the address of the currently executing instruction
  ip,
  # The stack pointer is manipulated by push, pop, call, and ret instructions
  sp,
  # The frame pointer is technically general purpose, but the blessed calling
  # convention uses it to point to the start of each function's stack frame
  fp,
  # "Return Value" for function calls
  rv,
  # "Condition" register, holds the result of the last test instruction
  cond,
  # "Argument" registers, which are used to pass arguments to functions
  a1, a2, a3, a4,
  # "Register" registers, general purpose
  r1, r2, r3, r4
]

symbols:
  type: [function, data]
  # Only public symbols can be linked with
  visibility: [public, private]
  # Internal linkage means that the symbol is defined in this module
  # External linkage means that this symbol needs to be resolved and needs
  #  to be provided by another module
  linkage: [internal, external]

architecture:
  pagesize: 128

# Module Layout
#

# Symbol Table
# The symbol table for a module is a list of tuples:
#  (type[1byte], visibility[1byte], linkage[1byte], location[4byte])

# Dynamically Allocated Memory
# maybe have an instruction (newpage) that fetches a new page and returns its address?
# the standard library could then have a malloc function that calls this on startup and
# stores the base address of the heap

